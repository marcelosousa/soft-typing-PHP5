imports
{
import Data.Graph.Inductive hiding (graphviz', Node, empty, nodes)
import Data.Graph.Inductive.Tree
}

-------------------------------------------------------------------------------
-- Pretty Printer for AST
-------------------------------------------------------------------------------

attr Node
    syn nodeList use {++} {[]}:: {[LNode String]}
    syn edgeList use {++} {[]}:: {[UEdge]}

sem Node
    -- Functions
    | FunctionDecl
        loc.label = @loc.ln 
        +nodeList = (++) [(@ln, "function " ++ @name)]
        +edgeList = (++) [(@ln, @stmt.label, ())]
    | SimplifiedFunctionCall
        loc.label = @loc.lc
        +nodeList = (++) [(@lc, @name ++ "() [lb: " ++ show @lb ++ ", lc: " ++ show @lc ++ ", lr: " ++ show @lr ++ ", la: " ++ show @la ++ "]")]
    | Return 
        +nodeList = (++) [(@label, "return")]
        +edgeList = (++) [(@label, @e.label, ())]
        
    -- Statements    
    | Sequence 
        +nodeList = (++) [(@label, ";")]
        +edgeList = (++) [(@label, @f.label, ()), (@label, @s.label, ())]
    | Skip
        +nodeList = (++) [(@label, "[skip]")]    
    | Expr 
        +nodeList = (++) [(@label, "expr")]
        +edgeList = (++) [(@label, @e.label, ())]
    | If 
        +nodeList = (++) [(@label, "if")]
        +edgeList = (++) [(@label, @c.label, ()), (@label, @l.label, ()), (@label, @r.label, ())]
    | While
        +nodeList = (++) [(@label, "while")]
        +edgeList = (++) [(@label, @c.label, ()), (@label, @s.label, ())]
    
    -- Debugging & Unit Testing
    | Expect
        lhs.nodeList = [(@label, "expect: " ++ render @expr.pp ++ " == " ++ show @ty)]
               
    -- Expressions
    | Deci Plus Min Mul Mod LTrue LFalse LAnd LOr LXor Not And Or Assign PlusAssign MinAssign MulAssign DivAssign ModAssign ConcatAssign IsEqual IsIdentical IsNotEqual IsNotIdentical Less Greater LessEqual GreaterEqual
        +nodeList = (++) [(@label, toString @self)]    

    | Assign PlusAssign MinAssign MulAssign DivAssign ModAssign ConcatAssign    
        lhs.edgeList = [(@label, @rv.label, ()), (@label, @e.label, ())] ++ @e.edgeList

    | Variable 
        +nodeList = (++) [(@label, "$" ++ render @n.pp)]
    | String
        +nodeList = (++) [(@label, @value)]

    | Echo
        +nodeList = (++) [(@label, "echo")]
        +edgeList = (++) [(@label, @e.label, ())]

    -- | Connect binary operators
    | Plus Min Mul Mod IsEqual IsIdentical IsNotEqual IsNotIdentical Less Greater LessEqual GreaterEqual LAnd LOr LXor And Or
        +edgeList = (++) [(@label, @l.label, ()), (@label, @r.label, ())]

    | Not
        +edgeList = (++) [(@label, @e.label, ())]

    | Print
        +nodeList = (++) [(@label, "print")]
        +edgeList = (++) [(@label, @e.label, ())]
    | PostInc 
        +nodeList = (++) [(@label, "PostInc")]
        +edgeList = (++) [(@label, @e.label, ())]
    | PreInc
        +nodeList = (++) [(@label, "PreInc")]
        +edgeList = (++) [(@label, @e.label, ())]
    | InlineHTML
        +nodeList = (++) [(@label, "InlineHTML")]
        
{

--visualize p = trace ("nodes: " ++ show nodeList ++ ", edges: " ++ show edgeList ++ ", p: " ++ show p) $ graphviz' (mkGraph nodeList edgeList :: Gr String ())
visualize p = graphviz' (mkGraph nodeList edgeList :: Gr String ())
    where
        nodeList = nodeList_Syn_Node . execute M.empty undefined $ p
        edgeList = edgeList_Syn_Node . execute M.empty undefined $ p
        
        
graphviz' g = let n = labNodes g
                  e = labEdges g
                  
                  ns = concatMap sn n
                  es = concatMap se e
                  
                  sn (l, a)     = show l ++ " [label=\"" ++ a ++ " (" ++ show l ++ ") \"];"
                  se (l, l', a) = show l ++ " -> " ++ show l' ++ ";"
                  
              in "digraph AST { bgcolor=transparent; " ++ ns ++ es ++ "}"
  
        
}