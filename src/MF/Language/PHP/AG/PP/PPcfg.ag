imports
{
import CCO.Printing as P hiding (render, join) 
import Data.IntMap as IM
import Data.Map as M
import Data.Set as S
import qualified Debug.Trace as TR
}

-------------------------------------------------------------------------------
-- Pretty Printer for control flow graph
-- Since the Node is a flat structure it's not easy to generate a 
-- dot file with the DOT package.
-------------------------------------------------------------------------------

attr Node MaybeNode 
    syn ppcfg use {>|<} {P.empty} :: {Doc}
    syn labstruct use {`IM.union`} {IM.empty} :: {IntMap String}

    inh struct :: String
    inh res :: {ValueMap (Identifier :-> TypeSet)}

sem MaybeNode
    | Just lhs.ppcfg = @just.ppcfg
    | Nothing lhs.ppcfg = P.empty
    
sem Node
    | Document 
        lhs.ppcfg = text "digraph structs {" >-< 
                    text "bgcolor=transparent;" >-<
                    text "node [shape=Mrecord];" >-<
                    text "init [label=\"init\", shape=circle]" >-<
                    text "final [label=\"final\", shape=circle, style=filled, fillcolor=gray]" >-<
                    @stmt.ppcfg >-<
                    @loc.flowp >-<                    
                    text "}"
        loc.flowp = text "init -> " >|< text (buildLabelRef @stmt.labstruct (fromJust @init)) >|< text ";" >-<
                    above [text (buildLabelRef @stmt.labstruct f) >|< text "-> final;" | f <- fromJust @final] >-<
                    ppConns @stmt.flow @stmt.labstruct

    -- Sequence (lists in the grammar are converted to a sequence by Base.ag) 
    | Sequence 
        lhs.ppcfg = @f.ppcfg >-< @s.ppcfg

        --                    text ("cond" ++ show @label) >|< dotLabel @c.ppcfg >|< @l.ppcfg >|< @r.ppcfg >-<         
        --FunctionDecl name :: String params :: ParamList stmt :: Node
    | FunctionDecl -- missing the params
        lhs.ppcfg = text ("subgraph cluster_"++(show @label)++" {") >-<
                    text "style=filled;" >-<
                    text "color=lightblue;" >-<
                    text (show @loc.ln) >|< text " [label=\"entry" >|< dotAnnotate @loc.ln >|< text "\", shape=circle]" >-<
                    text (show @loc.lx) >|< text " [label=\"exit" >|< dotAnnotate @loc.lx >|< text "\", shape=circle, style=filled, fillcolor=gray]" >-<
                    @stmt.ppcfg >-<
                    text "label = \"function " >|< text @name >|< text "\"; }"
        loc.sname = "fun"++show @label
        lhs.labstruct = @stmt.labstruct
        stmt.res  = @lhs.res

    -- Introduced by the simplifier: result = name (params)
    --    | SimplifiedFunctionCall name :: String params :: ParamList result :: {Maybe Node}
    | SimplifiedFunctionCall
        lhs.ppcfg = text ("subgraph cluster_"++(show @loc.lc)++" {") >-<
                    text "color=green;" >-<
                    text (show @loc.lc) >|< text " [label=\"call " >|< text @name >|< dotAnnotate @loc.lc >|< 
                    ppMapping (@loc.lattice @loc.lc) >|<
                    text " \"]" >-<
                    text (show @loc.la) >|< text " [label=\"$" >|< text (name (fromJust @result.self)) >|< text " after " >|< dotAnnotate @loc.la >|<
                    ppMapping (@loc.lattice @loc.la) >|< text "\"]" >-<
                    text (show @loc.lr) >|< text " [label=\"return " >|< text @name >|< dotAnnotate @loc.lr >|<
                    ppMapping (@loc.lattice @loc.lc) >|< 
                    text "\", style=filled, fillcolor=gray]" >-<
                    text (show @loc.lb) >|< text " [label=\"$" >|< text (name (fromJust @result.self)) >|< text " before " >|< dotAnnotate @loc.lb >|< 
                    ppMapping (@loc.lattice @loc.lb) >|< text "\"]" >-<
                    text "label = \"call " >|< text @name >|< text "\"; }"
--                    @params.ppcfg >-<
        result.struct = @loc.sname
        loc.sname = "res" ++ show @loc.lr
        loc.lattice = \l -> fromMaybe M.empty $ IM.lookup l @lhs.res        

    -- Variables
    | Variable 
        lhs.ppcfg = dotPort @label >|< 
                    text "$" >|< @n.ppcfg >|< 
                    dotAnnotate @label >|<
                    ppMapping @loc.lattice
        +labstruct  = IM.union $ IM.singleton @label @lhs.struct
        loc.lattice = fromMaybe M.empty $ IM.lookup @label @lhs.res
            
    | Expr
        lhs.ppcfg = text @loc.sname >|< dotLabel @e.ppcfg
        e.struct = @loc.sname
        loc.sname = "expr" ++ show @label

    | Return
        lhs.ppcfg = text @loc.sname >|< 
                    dotLabel (dotPort @label >|< text "return" >|< dotAnnotate @label >|< ppMapping @loc.lattice >|< text " | " >|< @e.ppcfg)
        e.struct = @loc.sname
        loc.sname = "expr" ++ show @label
        loc.lattice = myfromJust $ IM.lookup @label @lhs.res
        +labstruct = IM.union $ @e.labstruct `IM.union` (IM.singleton @label @loc.sname)

    | If
        lhs.ppcfg = text ("subgraph cluster_"++(show @label)++" {") >-<
                    text "color=lightgrey;" >-<
                    text ("cond" ++ show @label) >|< dotLabel @c.ppcfg >|< @l.ppcfg >|< @r.ppcfg >-< 
                    text "label = \"if #" >|< text (show @label) >|< text "\"; }"
        c.struct = "cond" ++ show @label

    | While
        lhs.ppcfg = text ("subgraph cluster_"++(show @label)++" {") >-<
                    text "color=lightgrey;" >-<
                    text ("cond" ++ show @label) >|< dotLabel @c.ppcfg >|< @s.ppcfg >-< 
                    text "label = \"while #" >|< text (show @label) >|< text "\"; }"
        c.struct = "cond" ++ show @label

    | Simple
        lhs.ppcfg = text @value
        
    | Assign
        lhs.ppcfg = @rv.ppcfg >|< 
                    text " | " >|< dotPort @label >|< text "= " >|< 
                    dotAnnotate @label >|<
                    ppMapping @loc.lattice >|< text " | " >|< 
                    @e.ppcfg
        loc.lattice = myfromJust $ IM.lookup @label @lhs.res
        +labstruct = IM.union $ @rv.labstruct `IM.union` @e.labstruct `IM.union` (IM.singleton @label @lhs.struct)
  
    -- Arithmetic
    | LTrue
      lhs.ppcfg = dotPort @label >|< 
                  text "true" >|< 
                  dotAnnotate @label    
      +labstruct = IM.union $ IM.singleton @label @lhs.struct      
    
    | String
        lhs.ppcfg = dotPort @label >|< 
                    ppString @value >|< 
                    dotAnnotate @label >|<
                    ppMapping @loc.lattice
        +labstruct = IM.union $ IM.singleton @label @lhs.struct
        loc.lattice = myfromJust $ IM.lookup @label @lhs.res
        
    | Deci
        lhs.ppcfg = dotPort @label >|< 
                    text (show @value) >|< 
                    dotAnnotate @label -->|<
--                    ppMapping @loc.lattice
        +labstruct = IM.union $ IM.singleton @label @lhs.struct
--        loc.lattice = myfromJust $ IM.lookup @label @lhs.res
    
    | Skip
        lhs.ppcfg = text @loc.labtag >|< dotLabel (dotPort @label >|< text "Skip" >|< dotAnnotate @label)
        +labstruct = IM.union $ IM.singleton @label @loc.labtag
        loc.labtag = "skip" ++ show @label

{
dotAnnotate :: Show a => a -> Doc
dotAnnotate a = text " (" >|< text (show a) >|< text ") "

dotLabel :: Doc -> Doc
dotLabel d = text " [label=\"" >|< d >|< text "\"];"

dotPort :: Show a => a -> Doc
dotPort a = angles $ text (show a) 

sChar :: Doc
sChar = text "\\\""

ppString :: String -> Doc
ppString s = enclose sChar sChar (text s)

ppConns :: Flow -> IntMap String -> Doc
ppConns flow structags = above $ L.map (\f -> ppConn f structags) flow

ppConn :: (Label, Label) -> IntMap String -> Doc
ppConn (l,l') labeltags = text (buildLabelRef labeltags l) >|< text "-> " >|< text (buildLabelRef labeltags l') >|< text ";"

ppMapping :: Mapping -> Doc
ppMapping m = foldr (\d r -> if P.isEmpty r then d else d >|< comma >|< r) P.empty (L.map ppMappingElem (M.toList m))
    where ppMappingElem (id, tys) = text "\\n ( " >|< ppIdentifier id >|< text "\\=\\>" >|< ppTypeSet tys >|< text ")" 

ppIdentifier :: Identifier -> Doc
ppIdentifier (Identifier s) = text "$" >|< text s
ppIdentifier (Parameter i)  = text "Param " >|< text (show i)
ppIdentifier (ReturnValue)  = text "ReturnValue"

ppTypeSet :: TypeSet -> Doc
ppTypeSet tys = text "\\{ " >|< foldr (\d r -> if P.isEmpty r then d else d >|< comma >|< r) P.empty (L.map ppType (S.elems tys)) >|< text "\\}"
    where ppType = text . show

buildLabelRef :: IntMap String -> Label -> String
buildLabelRef imap l = case IM.lookup l imap of
                            Just s -> s ++ ":" ++ (show l)
                            Nothing -> show l -- error $ show imap ++ show l

cfgprinter :: Component Node (IM.IntMap (Doc, FlowOut))
cfgprinter = component $ return . cfgprint
             
cfgprint n = IM.map (\(it, w) -> (ppcfg_Syn_Node $ execute M.empty it n, w)) (typing n)


--ppcfg_Syn_Node $ execute M.empty (last $ IM.elems $ typing n) n

}      
