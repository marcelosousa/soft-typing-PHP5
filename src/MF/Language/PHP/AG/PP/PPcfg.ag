imports
{
import CCO.Printing as P hiding (render, join) 
import Data.IntMap as IM
import Data.Map as M
import Data.Set as S
}

-------------------------------------------------------------------------------
-- Pretty Printer for control flow graph
-- Since the Node is a flat structure it's not easy to generate a 
-- dot file with the DOT package.
-------------------------------------------------------------------------------

attr Node
    syn ppcfg use {>|<} {P.empty} :: {Doc}
    syn labstruct use {`IM.union`} {IM.empty} :: {IntMap String}
    syn flowpp use {>|<} {P.empty} :: {Doc}
    inh struct :: String
    inh res :: {ValueMap (Identifier :-> TypeSet)}
        
sem Node
    | Document 
        lhs.ppcfg = text "digraph structs {" >-< 
                    text "node [shape=Mrecord];" >-<
                    text "init [label=\"init\", shape=circle]" >-<
                    text "final [label=\"final\", shape=circle, style=filled, fillcolor=gray]" >-<
                    @stmt.ppcfg >-<
                    @loc.flowp >-<                    
                    text "}"
        loc.flowp = text "init -> " >|< text (buildLabelRef @stmt.labstruct (fromJust @init)) >|< text ";" >-<
                    above [text (buildLabelRef @stmt.labstruct f) >|< text "-> final;" | f <- fromJust @final] >-<
                    @stmt.flowpp

    -- Sequence (lists in the grammar are converted to a sequence by Base.ag) 
    | Sequence 
        lhs.ppcfg = @f.ppcfg >-< @s.ppcfg
        +flowpp = (>-<) $ above [text (buildLabelRef @loc.lstr l) >|< text "-> " >|< text (buildLabelRef @loc.lstr l') >|< text ";" | (l,l') <- @loc.flow]  
        loc.lstr = @f.labstruct `IM.union` @s.labstruct 
        lhs.labstruct = @loc.lstr

    -- Variables
    | Variable 
        lhs.ppcfg = text "<" >|< text (show @label) >|< text "> " >|< 
                    text "$" >|< @n.ppcfg >|< 
                    text " (" >|< text (show @label) >|< text ") " >|<
                    ppMapping @loc.lattice
        +labstruct = IM.union $ IM.singleton @label @lhs.struct
        loc.lattice = fromJust $ IM.lookup @label @lhs.res
            
    | Expr
        lhs.ppcfg = text ("struct" ++ show @label) >|< text " [label=\"" >|<
                    @e.ppcfg >|< text "\"];"
        e.struct = "struct" ++ show @label
                    
    | Simple
        lhs.ppcfg = text @value
        
    | Assign
        lhs.ppcfg = @rv.ppcfg >|< 
                    text " | <" >|< text (show @label) >|< text "> = " >|< 
                    text " (" >|< text (show @label) >|< text ") " >|< 
                    ppMapping @loc.lattice >|< text " | " >|< 
                    @e.ppcfg
        lhs.flowpp = above [text (buildLabelRef @loc.lstr l) >|< text "-> " >|< text (buildLabelRef @loc.lstr l') >|< text ";" | (l,l') <- @loc.flow]
        rv.struct = @lhs.struct
        e.struct = @lhs.struct        
        loc.lstr = @rv.labstruct `IM.union` @e.labstruct `IM.union` (IM.singleton @label @lhs.struct)
        loc.lattice = fromJust $ IM.lookup @label @lhs.res
        +labstruct = IM.union @loc.lstr
        
    -- Arithmetic
    | Deci
        lhs.ppcfg = text "<" >|< text (show @label) >|< text "> " >|< 
                    text (show @value) >|< 
                    text " (" >|< text (show @label) >|< text ") " >|<
                    ppMapping @loc.lattice
        +labstruct = IM.union $ IM.singleton @label @lhs.struct
        loc.lattice = fromJust $ IM.lookup @label @lhs.res

{
ppMapping :: Mapping -> Doc
ppMapping m = foldr (\d r -> if P.isEmpty r then d else d >|< comma >|< r) P.empty (L.map ppMappingElem (M.toList m))
    where ppMappingElem (id, tys) = text "\\n ( " >|< ppIdentifier id >|< text "\\=\\>" >|< ppTypeSet tys >|< text ")" 

ppIdentifier :: Identifier -> Doc
ppIdentifier (Identifier s) = text "$" >|< text s
ppIdentifier (Parameter i)  = text "Param " >|< text (show i)
ppIdentifier (ReturnValue)  = text "ReturnValue"

ppTypeSet :: TypeSet -> Doc
ppTypeSet tys = text "\\{ " >|< foldr (\d r -> if P.isEmpty r then d else d >|< comma >|< r) P.empty (L.map ppType (S.elems tys)) >|< text "\\}"
    where ppType = text . show

buildLabelRef :: IntMap String -> Label -> String
buildLabelRef imap l = case IM.lookup l imap of
                            Just s -> s ++ ":" ++ (show l)
                            Nothing -> error $ show imap ++ show l

cfgprinter :: Component Node (IM.IntMap Doc)
cfgprinter = component $ return . cfgprint
             
cfgprint n = IM.map (\it -> ppcfg_Syn_Node $ execute M.empty it n) (typing n)
--ppcfg_Syn_Node $ execute M.empty (last $ IM.elems $ typing n) n

}      
