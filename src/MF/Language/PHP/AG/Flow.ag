imports
{
import Data.IntMap as IM
import Data.Map as M
import Data.Maybe
import Control.Applicative

import qualified MF.Core.Flowable as F
import MF.Core.Flowable hiding (Return)
}

-------------------------------------------------------------------------------
-- Labelling & Nodes
-------------------------------------------------------------------------------

attr Node ParamList MaybeNode
    inh labels :: {Label}
    syn labels :: {Label}

    syn label  :: {Label}
  
attr Node ParamList
    syn nodes use {`IM.union`} {IM.empty} :: {IntMap Node}

sem Node
    | If While Skip Assign Sequence Simple Deci Variable LTrue LFalse Plus Min Mul Mod ArrayAccess Return IsEqual GreaterEqual Or Expect Return FunctionCall Param String Expr DQContent FunctionName Literal Echo Print
        loc.label :: uniqueref labels
        lhs.label = @loc.label
        +nodes    = IM.union $ IM.singleton @label @self
        
    | FunctionDecl
        loc.ln :: uniqueref labels  -- Entry
        loc.lx :: uniqueref labels  -- Exit
        +nodes    = IM.union $ IM.singleton @label @self
        
    | SimplifiedFunctionCall
        loc.lb :: uniqueref labels  -- Before
        loc.lc :: uniqueref labels  -- Call
        loc.lr :: uniqueref labels  -- Return
        loc.la :: uniqueref labels  -- After
        +nodes    = IM.union $ IM.singleton @label @self

sem ParamList
    | Cons Nil
        loc.label :: uniqueref labels
        lhs.label = @loc.label

-------------------------------------------------------------------------------
-- Init
-------------------------------------------------------------------------------
       
attr Node
  syn init use {<|>} {Nothing} :: {Maybe Label}

sem Node
    | Document 
        loc.init = @stmt.init
        lhs.init = @loc.init
    | SimplifiedFunctionCall
        lhs.init = Just @lb
    | Skip Expect Return
        lhs.init = Just @label
    | If While
        lhs.init = @c.init
    | Expr
        lhs.init = @e.init
    | Assign
        lhs.init = @e.init
    | Sequence 
        lhs.init = @f.init <|> @s.init
    | Block
        lhs.init = @s.init
    | FunctionDecl
        lhs.init = Nothing
    | Variable
        lhs.init = Just @label
    | Plus Min Mul Mod IsEqual GreaterEqual
        lhs.init = @r.init
    | Deci LTrue LFalse String
        lhs.init = Just @label
        
        
-------------------------------------------------------------------------------
-- Final
-------------------------------------------------------------------------------

attr Node
  syn final use {<|>} {Nothing} :: {Maybe [Label]}

sem Node
    | Document 
        loc.final = @stmt.final 
        lhs.final = @loc.final
    | SimplifiedFunctionCall
        lhs.final = Just [@la]
    | Skip Expect Return Assign Variable 
        lhs.final = Just [@label]
    | While
        lhs.final = @c.final
    | Expr 
        lhs.final = @e.final
    | Deci LTrue LFalse String Plus Min Mul Mod IsEqual GreaterEqual
        lhs.final = Just [@label]
    | Sequence 
        lhs.final = @s.final <|> @f.final
    | If
        lhs.final = pure (++) <*> @l.final <*> @r.final
    | Block 
        lhs.final = @s.final
    | FunctionDecl
        lhs.final = Nothing
                             
-------------------------------------------------------------------------------
-- Flow
-------------------------------------------------------------------------------

{
myfromJust :: Maybe a -> a
myfromJust Nothing = error "myfromJust : Nothing"
myfromJust (Just a) = a
}

attr Node
  syn flow use {++} {[]} :: {Flow}

sem Node
    | Sequence 
        +flow = (++) $ if isNothing @s.init || isNothing @f.final then [] else [(l, fromJust @s.init) | l <- fromJust @f.final]
    | If 
        +flow = (++) $ [(label, myfromJust @l.init) | label <- myfromJust @c.final] ++ [(label, myfromJust @r.init) | label <- myfromJust @c.final]
    | While 
        +flow = (++) $ [(l, fromJust @s.init) | l <- fromJust @c.final ] ++ [(l', fromJust @c.init) | l' <- fromJust @s.final]
    | Return
        +flow = (++) $ [(@label, lx @lhs.declaration)]
    | FunctionDecl
        +flow = (++) $ [(@ln, myfromJust @stmt.init)]
    | SimplifiedFunctionCall
        +flow = let (Declaration name ln lx) = lookupDeclaration @name @lhs.declarations'
                in (++) [(@lb, @la), (@lb, @lc), (@lr, @la), (@lc, ln), (lx, @lr)]
    | Assign
        +flow = (++) $ [(l', fromJust @rv.init) | l' <- fromJust @e.final] ++ [(l', @label) | l' <- fromJust @rv.final]
    | Plus Min Mul Mod  IsEqual GreaterEqual
        +flow = (++) $ [(l', fromJust @l.init) | l' <- fromJust @r.final] ++ [(l', @label) | l' <- fromJust @l.final]

{
lookupDeclaration name declarations = case M.lookup name declarations of 
                                          Nothing   -> error $ "Calling an undefined function: " ++ name
                                          Just info -> info
}

-------------------------------------------------------------------------------
-- Function Declarations
-------------------------------------------------------------------------------

{
data Declaration = Declaration { functionName :: String, ln :: Label, lx :: Label }
}

attr Node ParamList
    syn declarations use {`M.union`} {M.empty} :: {Map String Declaration}
    inh declarations'                          :: {Map String Declaration}
    
    inh declaration :: {Declaration}
    
sem Node
    | Document
        stmt.declarations' = @stmt.declarations
    | FunctionDecl
        loc.declaration = Declaration @name @ln @lx
        stmt.declaration = @loc.declaration
        +declarations   = M.union $ M.singleton @name @loc.declaration

-------------------------------------------------------------------------------
-- Blocks
-------------------------------------------------------------------------------
        
attr Node
    syn blocks use {`IM.union`} {IM.empty} :: {IntMap (Block Node)}

sem Node
    | Skip Expect Assign Variable Deci Return LTrue LFalse String Plus Min Mul Mod IsEqual GreaterEqual
        +blocks = IM.union $ IM.singleton @label $ Normal @self
    | SimplifiedFunctionCall
        +blocks = IM.union $ IM.fromList [(@lb, Normal Skip)
                                 ,(@lc, Call @lc @lr @self)
                                 ,(@lr, F.Return @lc @lr @self)
                                 ,(@la, Normal Skip)]
    | FunctionDecl 
        +blocks = IM.union $ IM.fromList [(@ln, Entry @self)
                                 ,(@lx, Exit @self)]

{
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

-- Make Node an instance of Flowable, in this way it can be consumed by a monotone framework
instance Flowable Node where
    init     = fromJust . init_Syn_Node . execute M.empty undefined
    final    = fromJust . final_Syn_Node . execute M.empty undefined
    flow     = flow_Syn_Node . execute M.empty undefined
    blocks   = blocks_Syn_Node . execute M.empty undefined

debugflow n = "Doc: " ++ (show n) ++ 
              "\nInit: " ++ (show . F.init $ n) ++ 
              "\nFinal: " ++ (show . F.final $ n) ++ 
              "\nBlocks: " ++ (show . F.blocks $ n) ++
              "\nFlow: " ++ (show . F.flow $ n) ++ 
              "\nLabels: " ++ (show . F.labels $ n) ++
              "\nNodes: " ++ (show . nodes_Syn_Node . execute M.empty undefined $ n)
}