imports
{
import Data.IntMap as IM
import Data.Map as M
import Data.Maybe
import Control.Applicative

import qualified MF.Core.Flowable as F
import MF.Core.Flowable hiding (Return)
}

-------------------------------------------------------------------------------
-- Labelling & Nodes
-------------------------------------------------------------------------------

attr Node ParamList MaybeNode
    inh labels :: {Label}
    syn labels :: {Label}

    syn label  :: {Label}
  
attr Node ParamList
    syn nodes use {`IM.union`} {IM.empty} :: {IntMap Node}

sem Node
    | If While Skip Assign PlusAssign MinAssign MulAssign DivAssign ModAssign ConcatAssign Sequence Simple Deci Variable LTrue LFalse Plus Min Mul Mod ArrayAccess Return Expect Return FunctionCall Param String Expr DQContent FunctionName Literal Echo Print PostInc PreInc IsEqual IsIdentical IsNotEqual IsNotIdentical Less Greater LessEqual GreaterEqual LAnd LOr LXor And Or Not InlineHTML
        loc.label :: uniqueref labels
        lhs.label = @loc.label
        +nodes    = IM.union $ IM.singleton @label @self
        
    | FunctionDecl
        loc.ln :: uniqueref labels  -- Entry
        loc.lx :: uniqueref labels  -- Exit
        +nodes    = IM.union $ IM.singleton @label @self
        
    | SimplifiedFunctionCall
        loc.lb :: uniqueref labels  -- Before
        loc.lc :: uniqueref labels  -- Call
        loc.lr :: uniqueref labels  -- Return
        loc.la :: uniqueref labels  -- After
        +nodes    = IM.union $ IM.singleton @label @self

sem ParamList
    | Cons Nil
        loc.label :: uniqueref labels
        lhs.label = @loc.label

-------------------------------------------------------------------------------
-- Init
-------------------------------------------------------------------------------
       
attr Node
  syn init use {<|>} {Nothing} :: {Maybe Label}

sem Node
    | Document 
        loc.init = @stmt.init
        lhs.init = @loc.init
    | SimplifiedFunctionCall
        lhs.init = Just @lb
    | Skip Expect Return InlineHTML
        lhs.init = Just @label
    | If While
        lhs.init = @c.init
    | Expr
        lhs.init = @e.init
    | Assign PlusAssign MinAssign MulAssign DivAssign ModAssign ConcatAssign Not
        lhs.init = @e.init
    | Sequence 
        lhs.init = @f.init <|> @s.init
    | Block
        lhs.init = @s.init
    | FunctionDecl
        lhs.init = Nothing
    | Variable
        lhs.init = Just @label
    | Plus Min Mul Mod IsEqual IsIdentical IsNotEqual IsNotIdentical Less Greater LessEqual GreaterEqual LAnd LOr LXor And Or 
        lhs.init = @r.init
    | Deci LTrue LFalse String
        lhs.init = Just @label
    | Print Echo
        lhs.init = @e.init
    | PostInc PreInc
        lhs.init = @e.init
        
-------------------------------------------------------------------------------
-- Final
-------------------------------------------------------------------------------

attr Node
  syn final use {<|>} {Nothing} :: {Maybe [Label]}

sem Node
    | Document 
        loc.final = @stmt.final 
        lhs.final = @loc.final
    | SimplifiedFunctionCall
        lhs.final = Just [@la]
    | InlineHTML Skip Expect Return Assign PlusAssign MinAssign MulAssign DivAssign ModAssign ConcatAssign Variable Print Echo
        lhs.final = Just [@label]
    | While
        lhs.final = @c.final
    | Expr 
        lhs.final = @e.final
    | Deci LTrue LFalse String Plus Min Mul Mod PostInc PreInc IsEqual IsIdentical IsNotEqual IsNotIdentical Less Greater LessEqual GreaterEqual LAnd LOr LXor And Or Not  
        lhs.final = Just [@label]
    | Sequence 
        lhs.final = @s.final <|> @f.final
    | If
        lhs.final = pure (++) <*> @l.final <*> @r.final
    | Block 
        lhs.final = @s.final
    | FunctionDecl
        lhs.final = Nothing
                             
-------------------------------------------------------------------------------
-- Flow
-------------------------------------------------------------------------------

{
myfromJust :: Maybe a -> a
myfromJust Nothing = error "myfromJust : Nothing"
myfromJust (Just a) = a
}

attr Node
  syn flow use {++} {[]} :: {Flow}

sem Node
    | Sequence 
        +flow = (++) $ if isNothing @s.init || isNothing @f.final then [] else [(l, fromJust @s.init) | l <- fromJust @f.final]
    | If 
        +flow = (++) $ [(label, myfromJust @l.init) | label <- myfromJust @c.final] ++ [(label, myfromJust @r.init) | label <- myfromJust @c.final]
    | While 
        +flow = (++) $ [(l, fromJust @s.init) | l <- fromJust @c.final ] ++ [(l', fromJust @c.init) | l' <- fromJust @s.final]
    | Return
        +flow = (++) $ [(@label, lx @lhs.declaration)]
    | FunctionDecl
        +flow = (++) $ [(@ln, myfromJust @stmt.init)]
    | SimplifiedFunctionCall
        +flow = let (Declaration name ln lx) = lookupDeclaration @name @lhs.declarations'
                in (++) [(@lb, @la), (@lb, @lc), (@lr, @la), (@lc, ln), (lx, @lr)]
    | Print Echo PostInc PreInc Not
        +flow = (++) $ [(l', @label) | l' <- fromJust @e.final]
    | Assign PlusAssign MinAssign MulAssign DivAssign ModAssign ConcatAssign 
        +flow = (++) $ [(l', fromJust @rv.init) | l' <- fromJust @e.final] ++ [(l', @label) | l' <- fromJust @rv.final]
    | Plus Min Mul Mod IsEqual IsIdentical IsNotEqual IsNotIdentical Less Greater LessEqual GreaterEqual LAnd LOr LXor And Or
        +flow = (++) $ [(l', fromJust @l.init) | l' <- fromJust @r.final] ++ [(l', @label) | l' <- fromJust @l.final]

{
lookupDeclaration name declarations = case M.lookup name declarations of 
                                          Nothing   -> error $ "Calling an undefined function: " ++ name
                                          Just info -> info
}

-------------------------------------------------------------------------------
-- Function Declarations
-------------------------------------------------------------------------------

{
data Declaration = Declaration { functionName :: String, ln :: Label, lx :: Label }
}

attr Node ParamList
    syn declarations use {`M.union`} {M.empty} :: {Map String Declaration}
    inh declarations'                          :: {Map String Declaration}
    
    inh declaration :: {Declaration}
    
sem Node
    | Document
        stmt.declarations' = @stmt.declarations
    | FunctionDecl
        loc.declaration = Declaration @name @ln @lx
        stmt.declaration = @loc.declaration
        +declarations   = M.union $ M.singleton @name @loc.declaration

-------------------------------------------------------------------------------
-- Blocks
-------------------------------------------------------------------------------
        
attr Node
    syn blocks use {`IM.union`} {IM.empty} :: {IntMap (Block Node)}

sem Node
    | Skip Expect Assign PlusAssign MinAssign MulAssign DivAssign ModAssign ConcatAssign Variable Deci Return LTrue LFalse String Plus Min Mul Mod Print Echo PostInc PreInc IsEqual IsIdentical IsNotEqual IsNotIdentical Less Greater LessEqual GreaterEqual LAnd LOr LXor And Or Not
        +blocks = IM.union $ IM.singleton @label $ Normal @self
    | SimplifiedFunctionCall
        +blocks = IM.union $ IM.fromList [(@lb, Normal Skip)
                                 ,(@lc, Call @lc @lr @self)
                                 ,(@lr, F.Return @lc @lr @self)
                                 ,(@la, Normal Skip)]
    | FunctionDecl 
        +blocks = IM.union $ IM.fromList [(@ln, Entry @self)
                                 ,(@lx, Exit @self)]

{
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

-- Make Node an instance of Flowable, in this way it can be consumed by a monotone framework
instance Flowable Node where
    init     = fromJust . init_Syn_Node . execute M.empty undefined
    final    = fromJust . final_Syn_Node . execute M.empty undefined
    flow     = flow_Syn_Node . execute M.empty undefined
    blocks   = blocks_Syn_Node . execute M.empty undefined

debugflow n = "Doc: " ++ (show n) ++ 
              "\nInit: " ++ (show . F.init $ n) ++ 
              "\nFinal: " ++ (show . F.final $ n) ++ 
              "\nBlocks: " ++ (show . F.blocks $ n) ++
              "\nFlow: " ++ (show . F.flow $ n) ++ 
              "\nLabels: " ++ (show . F.labels $ n) ++
              "\nNodes: " ++ (show . nodes_Syn_Node . execute M.empty undefined $ n)
}