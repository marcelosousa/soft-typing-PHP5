optpragmas {
{-# LANGUAGE TypeOperators #-}
}

imports
{
import MF.Language.PHP.Types

import MF.Core.Solver as C
import MF.Core.Context
import MF.Core.Lattice

import Data.IntMap as IM
import Data.Set    as S
import Data.Map    as M
import Data.List   as L
import Data.Maybe

import qualified Debug.Trace as T
}

-------------------------------------------------------------------------------
-- Left most variable name and variable depth
-------------------------------------------------------------------------------

{
levels :: Node -> Int
levels (ArrayAccess rv index) = 1 + levels rv
levels (Variable n)           = 0
      
name :: Node -> String
name   (ArrayAccess rv index) = name rv
name   (Variable n)           = name n
name   (Simple value)         = value
}
  
attr Node ParamList
    inh simplifiedName :: {Maybe Node}
    
sem Node
    | ArrayAccess
        rv.simplifiedName = @lhs.simplifiedName <|> pure @self
    | Variable
        n.simplifiedName  = @lhs.simplifiedName <|> pure @self

-------------------------------------------------------------------------------
-- Constraints
-------------------------------------------------------------------------------

attr Node
    chn constraints :: {Set Constraint}  -- use {`S.union`} {S.empty} :: {Set Constraint} 
    
sem Node 
    | Return Expr Assign
        loc.constraints = @e.constraints
    | If While
        loc.constraints = @c.constraints
    | Assign
        lhs.constraints = S.fromList [(@rv.label :<=: @e.label), (@label :<=: @rv.label)] `S.union` @e.constraints -- `S.union` @rv.constraints
    | Deci 
        lhs.constraints = S.singleton (@label :==: S.singleton TyInt)
    | LTrue LFalse
        lhs.constraints = S.singleton (@label :==: S.singleton TyBool)
    | String
        lhs.constraints = S.singleton (@label :==: S.singleton TyString)
    | Plus Min Mod Mul
        +constraints    = S.union $ S.singleton (@label :==: S.singleton TyInt)  
    | IsEqual Or GreaterEqual
        +constraints    = S.union $ S.singleton (@label :==: S.singleton TyBool)
    | Variable
        +constraints    = S.union $ S.singleton (@label :<=: @n.label) 
    | ArrayAccess  
        +constraints    = S.union $ S.singleton (@label :<=: @rv.label)
    | Simple
        lhs.constraints = case M.lookup (Identifier @value) @lhs.mapping of 
                              Just c  -> S.singleton (@label :==: fromArrayRepeatedly (levels (fromJust @lhs.simplifiedName)) c)
                              Nothing -> S.singleton (@label :==: S.empty)
    | Expect 
        loc.constraints = S.singleton (@label :<=: @expr.label) `S.union` @expr.constraints
                                                                  
-------------------------------------------------------------------------------
-- Mapping
-------------------------------------------------------------------------------

attr Node ParamList
    syn mapping :: {Mapping}
    inh mapping :: {Mapping}
    
sem Node
    | Assign 
        lhs.mapping = updateMapping (Identifier $ name @rv.self) @e.label (levels @rv.self) @constraints @e.mapping
    | Return 
        lhs.mapping = updateMapping ReturnValue                  @e.label 0                 @constraints @e.mapping
      
-------------------------------------------------------------------------------
-- Solver
-------------------------------------------------------------------------------
{

solve :: Node -> ValueMap (ValueMap (Stack :-> Mapping), FlowOut)
solve = C.solve (lift transfer) (M.singleton [] M.empty) M.empty Forward
    where        
        transfer :: Block Node -> Mapping -> Mapping
        transfer (Normal Skip)          = id
        transfer (Normal (Expect _ _))  = id
        transfer (Normal (Deci _))      = id
        transfer (Normal s@(Variable _))= id
        transfer (Normal LTrue)         = id
        transfer (Normal (String _))    = id
        transfer (Normal (Plus _ _))    = id
        transfer (Normal (Min _ _))    = id
        transfer (Normal (Mul _ _))    = id
        transfer (Normal (Mod _ _))    = id
        transfer (Normal (IsEqual _ _)) = id
        transfer (Normal (GreaterEqual _ _)) = id
        transfer (Normal s@(Assign rv e)) = updateMapping s 
--        transfer (Normal (Expr e))      = id  this should be irrelevant
--        transfer (Normal (If c _ _ _ )) = updateMapping c
        transfer (Normal (While c _))   = updateMapping c
        transfer (Normal (Return e))    = updateMapping $ Return e
        transfer (Call lc lr (SimplifiedFunctionCall name params result)) = M.mapKeys identifierToParameter . M.filterWithKey (flip $ const isParameter)
            where
                isParameter (Identifier x) = x `elem` names
                isParameter _              = False
                identifierToParameter (Identifier x) = Parameter $ fromJust (elemIndex x names)
                names = L.map (toName . removeParam) params                                             
        transfer (Entry  (FunctionDecl name params _)) = M.mapKeys parameterToIdentifier 
            where
                parameterToIdentifier (Parameter p) = Identifier $ (toName . removeParam) (params !! p)
        transfer (Exit   (FunctionDecl name params _)) = M.filterWithKey (flip $ const isReturnValue)
            where
                isReturnValue ReturnValue = True
                isReturnValue _           = False
        transfer (F.Return lc lr (SimplifiedFunctionCall name params result)) = maybe id (\node -> M.mapKeys (returnValueToIdentifier node)) result 
            where
                returnValueToIdentifier node ReturnValue = Identifier $ toName node
        
        updateMapping :: Node -> Mapping -> Mapping
        updateMapping node mapping = mapping_Syn_Node . execute mapping IM.empty $ node
                
        removeParam :: Node -> Node   
        removeParam (Param expr) = expr 

        toName :: Node -> String
        toName (Variable (Simple name)) = name
        
-------------------------------------------------------------------------------
-- Typing
-------------------------------------------------------------------------------
     
typer :: Component Node (ValueMap (ValueMap (Identifier :-> TypeSet), FlowOut))
typer = component $ return . typing
             
typing :: Node -> ValueMap (ValueMap (Identifier :-> TypeSet), FlowOut)
typing p = trace ("mappings: " ++ show mappings) $ mappings
    where
        solve = MF.Language.PHP.AG.solve
        mappings = IM.map typing' (solve p) --IM.map ((m,w) -> ((IM.map (M.fold join M.empty) m), w)) (solve p)        

typing' :: (ValueMap (Stack :-> Mapping), FlowOut) -> (ValueMap (Identifier :-> TypeSet), FlowOut)
typing' (m,w) = (IM.map (M.fold join M.empty) m ,w)

-------------------------------------------------------------------------------
-- Report Typing
-------------------------------------------------------------------------------

reporterty :: Component (ValueMap (ValueMap (Identifier :-> TypeSet), FlowOut)) Doc
reporterty = component $ return . reporty'     
             
reporty' ::ValueMap (ValueMap (Identifier :-> TypeSet), FlowOut) -> Doc
reporty' m = IM.fold (\it r -> reporty (fst it) >-< r) P.empty m

reporty ::ValueMap (Identifier :-> TypeSet) -> Doc
reporty vm = IM.foldWithKey foldvm P.empty vm
            where foldvm i m r = text "Node num " >|< text (show i) >-< (M.foldrWithKey displayTypes P.empty m) >-< text "-----------" >-< r

displayTypes id ty r = text (show id) >|< text (show ty) >-< r

}